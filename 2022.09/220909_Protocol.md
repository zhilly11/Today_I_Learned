# Today_I_Learned

# ✏️ TIL (Today I Learned)

# 🔥 오늘의 목표

- [x]  MVC Model에 대한 고찰..
- [ ]  Protocol에 대한 고찰..
- [ ]  Delegate에 대한 고찰..

# ****🔥 오늘 공부한 내용****

## 과연 Apple 에서 말하는 MVC에서 Model이 뭐야!

- Apple의 MVC 공식문서에 따르면 모델은?
    
    응용 프로그램의 고유한 데이터를 캡슐화하고 해당 데이터를 조작 및 처리하는 논리와 계산을 정의한다. 모델은 다른 모델과 1:1, 1:N 관계를 가질 수 있으며, 따라서 애플리케이션 모델 레이어는 효과적으로 하나 이상의 객체 그래프가 될 수 있습니다. 앱의 지속상태에 속하는 데이터의 대부분은 데이터가 앱에 로드된 후 모델에 있어야 합니다. 모델은 데이터를 표시하고 사용자가 데이터를 편집할 수 있도록 하는 뷰에 명시적으로 접속하지 않는 것이 이상적입니다. 또한 사용자 인터페이스와 프레젠테이션의 문제는 관여하지 않는 것이 좋습니다.
    
- 즉 앱의 지속상태에 속하는 데이터 -> 데이터 모델이다.
    - 데이터로 사용하는 struct, class
    - 네트워크 로직 : 네트워크 요청을 하고, 그 결과를 받아오는 기본적인 기능을 담은 네트워크 로직
    - Persistance 로직 : 메모리에 저장되는 데이터를 로드 및 세이브 하는 로직
    - 데이터 파싱 로직: 네트워크로 받아오든 내부 파일에서 받아오든, JSON 같은 데이터가 왔을 때 이를 파싱하는 로직
    - Manager 객체 (shared 객체) : Class 를 만들어 두고 필요한 경우에 어디서든 접근해 사용할 수 있도록 따로 shared를 만드는 경우도 Model에 포함 된다.

<aside>
🤔 사실 이렇게 정리해 놔도 내가 만드는 내 프로젝트에 들어가보면 도저히 감이 안온다..
어디까지가 비즈니스 로직이고 어디까지가 모델에 들어갈 수 있는건지..

</aside>

## Protocol

프로토콜은 메서드, 프로퍼티, 그리고 특정 작업이나 기능의 부분이 적합한 다른 요구사항의 청사진을 정의합니다.

프로토콜은 요구사항의 구현을 제공하기 위해 클래스, 객체, 또는 열거형에 의해 채택될 수 있다.

포토코롱의 요구사항에 충족하는 모든 타입은 프로토콜에 **준수**한다고 한다.

준수하는 타입의 요구사항을 지정하는 것 외에도 요구 사항의 일부를 구현하거나 준수하는 타입에 추가기능을 구현하기 위해 프로토콜을 확장(Extension)할 수 있습니다.

---

## 프로토콜 구문 정의

클래스, 구조체, 그리고 열거형과 유사한 방법으로 정의합니다.

```swift
protocol SomeProtocol {
        // 프로토콜 정의는 여기에!
}
```

사용자 정의 타입은 콜론으로 구분된 타입의 이름 뒤에 특정 프로토콜의 이름을 적어 특정 프로토콜을 채택합니다.

여러 프로토콜은 콤마로 구분되고 목록화 할 수 있다.

```swift
struct SomeStructure: FirstProtocol, SecondProtocol {
        // sturct 정의는 여기에!
}
```

클래스가 상위 클래스를 가진 경우에는 콤마로 구분해서, 채택할 프로토콜 앞에 적는다.

```swift
class SomeClass: SomeSuperClass, FirstProtocol, SecondProtocol {
        // class 정의는 여기에!
}
```

---

## 프로퍼티 요구사항

프로퍼티는 특정 이름과 타입을 가진 인스턴스 프로퍼티 또는 타입 프로퍼티를 제공하기 위해 모든 준수하는 타입을 요구합니다. 프로토콜은 요구된 프로퍼티 이름과 타입만 지정하고 프로퍼티가 저장 또는 계산 프로퍼티인지에 대한 것은 지정하지 않습니다. 프로토콜은 각 프로퍼티가 gettable, settable에 대한 정보도 지정해줘야 합니다.

프로토콜이 gettable과 settable 인 프로퍼티를 요구할 경우 프로퍼티 요구사항은 저장된 프로퍼티 상수 또는 읽기전용 계산된 프로퍼티는 충족할 수 없습니다. 프로토콜이 gettable 인 프로퍼티 만 요구할 경우 이 요구사항은 모든 종류의 프로퍼티에 충족될 수 있고 이것이 유용한 경우 settable 또한 프로퍼티에 대해 유효합니다.

프로퍼티 요구사항은 항상 `var`키워드와 함께 변수 프로퍼티로 선언됩니다. gettable과 settable 프로퍼티는 타입 선언 뒤에 `{ get set }`으로 작성하여 나타내고 gettable 프로퍼티는 `{ get }`으로 작성하여 나타냅니다.

```swift
protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
```

항상 프로토콜에서 정의할 때 static 키워드 타입 프로퍼티 요구사항에 접두사로 둡니다. 이 규칙은 타입 프로퍼티 요구사항은 클래스에 의해 구현 될 때 class 또는 static 키워드를 붙일 수 있는 경우에도 적용되빈다.

```swift
protocol AnotherProtocol {
    static var someTypeProperty: Int { get set }
}
```

다음은 단일 인스턴스 프로퍼티 요구사항을 가지는 프로토콜 예시입니다.

```swift
protocol FullyNamed {
    var fullName: String { get }
}
```

`fullyNamed`프로토콜은 완벽한 이름을 제공하기 위해 준수하는 타입을 요구합니다. 이 프로토콜은 다른 준수하는 타입을 지정하지 않으며 타입이 자체에 대한 전체 이름을 제공해야 된다고만 지정합니다. 이 프로토콜은 모든 `FullyNamed` 타입이 `String` 타입의 `fullName` 이라는 gettable 인스턴스 프로퍼티를 가져야 합니다.

그럼 `fullyNamed`프로토콜을 채택하고 준수하는 구조체는?

```swift
struct Person: FullyNamed {
    var fullName: String
}
let john = Person(fullName: "John Appleseed")
// john.fullName is "John Appleseed"
```

 

이 예제는 특정 이름을 가진 사람을 나타내는 Person 이라는 구조체를 정의합니다. 첫 번째 줄을 보면 `fullyNamed`프로토콜도 채택하고 있습니다.

Person의 각 인스턴스는 String 타입의 fullName 이라는 단일 저장된 프로퍼티를 가집니다. 이것은 `fullyNamed`프로토콜의 단일 요구사항과 일치하고 Person은 프로토콜을 올바르게 준수하고 있다고 얘기합니다.

# ****🔥 오늘의 3줄 회고****

- 공휴일에는 집중력이 떨어지는것 같다^^
- 델리게이트는 아직 덤비지 말아봐,, 준비 안됨,,,
- 모델에 대한 고찰,, 어디까지가 모델일까? 비지니스 로직의 기준은?.. 이걸 보고계시다면 도움의 댓글을,,,,,,,
